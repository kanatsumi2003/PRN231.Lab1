using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Petalaka.Account.Contract.Repository.Entities;
using Petalaka.Account.Contract.Repository.Interface;
using Petalaka.Account.Contract.Repository.ModelViews.RequestModels;
using Petalaka.Account.Contract.Repository.ModelViews.ResponseModels;
using Petalaka.Account.Contract.Service.Interface;
using Petalaka.Account.Core.ExceptionCustom;
using Petalaka.Account.Core.Utils;

namespace Petalaka.Account.Service.Services;

public class AccountService : IAccountService
{
    private readonly UserManager<ApplicationUser> _userManager;
    private readonly SignInManager<ApplicationUser> _signInManager;
    private readonly IUnitOfWork _unitOfWork;
    private readonly ITokenService _tokenService;
    
    public AccountService(UserManager<ApplicationUser> userManager, 
        IUnitOfWork unitOfWork,
        SignInManager<ApplicationUser> signInManager,
        ITokenService tokenService)
    {
        _userManager = userManager;
        _unitOfWork = unitOfWork;
        _signInManager = signInManager;
        _tokenService = tokenService;
    }

    public async Task RegisterAccount(RegisterRequestModel request)
    {
        ApplicationUser user = await _unitOfWork.ApplicationUserRepository.FindUndeletedAsync(p => p.Email == request.Email || p.UserName == request.Username);
        if(user != null)
        {
            throw new CoreException(StatusCodes.Status400BadRequest, "User already exists");
        }
        //Generate salt and hash password with salt
        string salt = PasswordHasher.GenerateSalt();
        string hashedPassword = PasswordHasher.HashPassword(request.Password, salt);

        ApplicationUser newUser = new ApplicationUser
        {
            UserName = request.Username,
            Email = request.Email,
            PhoneNumber = request.PhoneNumber,
            FullName = request.FullName,
            CreatedBy = "System",
            LastUpdatedBy = "System",
            Salt = salt,
            PasswordHash = hashedPassword,
        };
        //create user with identity
        await _userManager.CreateAsync(newUser, hashedPassword);
        await _userManager.AddToRoleAsync(newUser, "user");
        /*
        await _unitOfWork.ApplicationUserRepository.InsertAsync(newUser);
        */
        await _unitOfWork.SaveChangesAsync();
    }
    
    public async Task<IEnumerable<ApplicationUser>> GetAllUsers()
    {
        return await _unitOfWork.ApplicationUserRepository.AsQueryable().ToListAsync();
    }
    
    public async Task<LoginResponseModel> Login(LoginRequestModel request)
    {
        ApplicationUser user = await _userManager.FindByEmailAsync(request.Email);
        if(user == null)
        {
            throw new CoreException(StatusCodes.Status400BadRequest, "User not found");
        }
        /*if(!PasswordHasher.VerifyPassword(request.Password, user.PasswordHash, user.Salt))
        {
            _signInManager.CheckPasswordSignInAsync()
            throw new CoreException(StatusCodes.Status400BadRequest, "Password is incorrect");
        }*/
        
        //get salt from database
        string salt = await _unitOfWork.ApplicationUserRepository.GetUserSalt(p => p.Email == request.Email);
        //hash password with salt
        string hashedPassword = PasswordHasher.HashPassword(request.Password, salt);
        //check if hashedPassword with salt is equal to passwordHash in database by identity (hashedPassword in database is generated by identity)
        var resultSucceeded = await _signInManager.CheckPasswordSignInAsync(user, hashedPassword, true);
        if(!resultSucceeded.Succeeded)
        {
            throw new CoreException(StatusCodes.Status400BadRequest, "Password is incorrect");
        }

        var signInResult = await _signInManager.PasswordSignInAsync(user, hashedPassword, true, false);
        if(!signInResult.Succeeded)
        {
            throw new CoreException(StatusCodes.Status400BadRequest, "Login failed");
        }

        var token = await _tokenService.GenerateTokens(user);
        return new LoginResponseModel
        {
            accessToekn = token.accessToken,
            refreshToken = token.refreshToken,
        };
    }
    
    
}